# Story 4.1: Asset Search & Matching

## Status

Draft

## Story

**As a** video producer,  
**I want** intelligent asset discovery that finds relevant visual content for each scene,  
**so that** I can automatically populate video scenes with appropriate background media from Pexels.

## Acceptance Criteria

1. Asset search triggered automatically when scripts are approved
2. Keyword-based Pexels search finds relevant videos and images per scene
3. Relevance scoring algorithm ranks assets by scene appropriateness
4. Fallback search hierarchies handle failed primary keyword matches
5. Local asset caching reduces API calls and improves performance
6. Asset metadata stored with download links and attribution info
7. Concurrent search processing handles multiple scenes efficiently
8. Search result deduplication prevents repeated asset suggestions
9. Asset quality filtering ensures minimum resolution and duration standards

## Acceptance Criteria

1. Asset search triggered automatically when scripts are approved
2. Keyword-based Pexels search finds relevant videos and images per scene
3. Relevance scoring algorithm ranks assets by scene appropriateness
4. Fallback search hierarchies handle failed primary keyword matches
5. Local asset caching reduces API calls and improves performance
6. Asset metadata stored with download links and attribution info
7. Concurrent search processing handles multiple scenes efficiently
8. Search result deduplication prevents repeated asset suggestions
9. Asset quality filtering ensures minimum resolution and duration standards

## Tasks / Subtasks

- [ ] **Task 1: Build Asset Search Orchestrator** (AC: 1, 7)
  - [ ] Create src/services/assets/searchOrchestrator.ts
  - [ ] Implement script approval trigger:
    - Listen for script_approved events
    - Extract scene breakdown and keywords
    - Queue asset search jobs per scene
    - Track search progress
  - [ ] Build concurrent search management:
    - Process multiple scenes in parallel
    - Limit concurrent API requests (3-5 max)
    - Queue overflow handling
    - Progress tracking per scene
  - [ ] Add search coordination:
    - Aggregate results from all scenes
    - Handle search failures gracefully
    - Notify when all searches complete
    - Update database with results
  - [ ] Test with multi-scene scripts

- [ ] **Task 2: Implement Keyword Processing** (AC: 2, 4)
  - [ ] Create src/services/assets/keywordProcessor.ts
  - [ ] Build keyword extraction enhancement:
    - Process Claude-generated keywords
    - Add synonym expansion
    - Remove stop words and articles
    - Generate semantic variations
  - [ ] Implement search hierarchy system:
    - Primary: Direct scene keywords
    - Secondary: Emotional tone keywords
    - Tertiary: General motivational terms
    - Fallback: Universal stock footage terms
  - [ ] Create fallback keyword database:
    - Motivational: "success", "achievement", "growth"
    - Nature: "sunrise", "mountain", "ocean", "forest"
    - Business: "meeting", "handshake", "office", "team"
    - Abstract: "light", "journey", "path", "future"
  - [ ] Add keyword optimization:
    - Remove duplicate keywords
    - Prioritize by relevance
    - Combine related keywords
    - Test search effectiveness

- [ ] **Task 3: Build Pexels Search Integration** (AC: 2, 8, 9)
  - [ ] Create src/services/assets/pexelsSearch.ts
  - [ ] Implement search execution:
    - Format search queries for Pexels API
    - Execute parallel video and image searches
    - Handle API rate limiting
    - Parse and structure responses
  - [ ] Add search parameters optimization:
    - Orientation: landscape preferred
    - Size: medium+ for videos, large for images
    - Video duration: 5-30 seconds
    - Quality: high definition minimum
  - [ ] Implement result deduplication:
    - Track Pexels IDs across searches
    - Remove duplicate assets
    - Prevent same asset in multiple scenes
    - Maintain search result diversity
  - [ ] Create search result validation:
    - Check minimum resolution (1920x1080)
    - Validate video duration limits
    - Verify asset availability
    - Filter inappropriate content

- [ ] **Task 4: Implement Relevance Scoring** (AC: 3)
  - [ ] Create src/services/assets/relevanceScoring.ts
  - [ ] Build scoring algorithm:
    - Keyword match score (40%)
    - Asset quality score (25%)
    - Duration appropriateness (20%)
    - Download/view popularity (15%)
  - [ ] Implement keyword matching:
    - Exact keyword matches (high weight)
    - Semantic similarity scoring
    - Tag relevance analysis
    - Description content analysis
  - [ ] Add quality metrics:
    - Resolution scoring
    - Video duration optimization
    - Photographer/creator reputation
    - Asset freshness factor
  - [ ] Create scene context scoring:
    - Emotional tone matching
    - Visual concept alignment
    - Scene position appropriateness
    - Content flow consistency
  - [ ] Test scoring accuracy with sample scenes

- [ ] **Task 5: Build Asset Caching System** (AC: 5, 6)
  - [ ] Create src/services/assets/cache.ts
  - [ ] Implement search result caching:
    - Cache search responses by keyword
    - TTL of 24 hours for search results
    - Cache invalidation strategy
    - Memory usage optimization
  - [ ] Build asset metadata storage:
    - Store Pexels metadata in database
    - Track download URLs and expiration
    - Maintain attribution information
    - Cache asset availability status
  - [ ] Add cache management:
    - Automatic cache cleanup
    - Cache warming for common keywords
    - Cache hit/miss analytics
    - Storage usage monitoring
  - [ ] Implement cache persistence:
    - Database storage for metadata
    - File system for downloaded assets
    - Cache rebuild on startup
    - Export/import cache data

- [ ] **Task 6: Create Asset Quality Control** (AC: 9)
  - [ ] Build quality filtering system:
    - Minimum resolution requirements
    - Video duration standards
    - File size validation
    - Format compatibility check
  - [ ] Implement content appropriateness:
    - Safe content filtering
    - Professional quality standards
    - Brand safety considerations
    - Age-appropriate content
  - [ ] Add technical validation:
    - Aspect ratio verification
    - Codec compatibility
    - Color space validation
    - Audio track handling
  - [ ] Create quality scoring:
    - Technical quality metrics
    - Aesthetic appeal scoring
    - Professional usage suitability
    - User engagement indicators

- [ ] **Task 7: Build Search Result Management** (AC: 6, 8)
  - [ ] Create database schema for assets:
    - Asset metadata storage
    - Search result tracking
    - Relevance score storage
    - Usage statistics
  - [ ] Implement result organization:
    - Group assets by scene
    - Rank by relevance score
    - Track asset usage history
    - Maintain search provenance
  - [ ] Add result optimization:
    - Remove low-scoring assets
    - Balance video vs image ratios
    - Ensure scene coverage
    - Optimize for video flow
  - [ ] Create result analytics:
    - Track search success rates
    - Monitor asset usage patterns
    - Identify keyword effectiveness
    - Performance metrics collection

- [ ] **Task 8: Implement Search Monitoring** (AC: 7)
  - [ ] Create search monitoring system:
    - Track API usage and limits
    - Monitor search success rates
    - Alert on search failures
    - Performance metrics tracking
  - [ ] Build search analytics:
    - Average search time per scene
    - API call efficiency
    - Cache hit rates
    - Quality score distributions
  - [ ] Add error monitoring:
    - API error rate tracking
    - Failed search analysis
    - Fallback usage statistics
    - Recovery success rates
  - [ ] Create search optimization:
    - Identify slow searches
    - Optimize keyword effectiveness
    - Improve fallback strategies
    - Enhance relevance scoring

- [ ] **Task 9: Create API Integration** (AC: 1, 2, 6)
  - [ ] Create src/routes/api/assets.ts
  - [ ] Implement asset search endpoints:
    - POST /api/assets/search/:scriptId - Trigger search
    - GET /api/assets/script/:scriptId - Get assets by script
    - GET /api/assets/scene/:sceneId - Get assets by scene
    - POST /api/assets/refresh/:scriptId - Refresh search results
  - [ ] Add search management endpoints:
    - GET /api/assets/search/status/:jobId - Search progress
    - GET /api/assets/cache/stats - Cache statistics
    - DELETE /api/assets/cache - Clear cache
  - [ ] Implement WebSocket notifications:
    - Search started events
    - Search progress updates
    - Search completed events
    - Error notifications
  - [ ] Test API functionality

## Dev Notes

### Architecture Context

- **Search Engine:** Pexels API with intelligent fallbacks
- **Processing:** Concurrent scene processing with rate limiting
- **Storage:** Database metadata + file system caching
- **Quality:** Multi-factor relevance scoring algorithm

### Asset Search Flow

```
Script Approved → Extract Keywords → Process Scenes in Parallel →
Pexels API Searches → Relevance Scoring → Deduplication →
Quality Filtering → Database Storage → WebSocket Notification
```

### Relevance Scoring Formula

```typescript
relevanceScore =
  (keywordMatch * 0.4 +
    assetQuality * 0.25 +
    durationFit * 0.2 +
    popularity * 0.15) *
  sceneContextBonus;

// Keyword Match (0-10)
keywordMatch = exactMatches * 3 + similarityScore * 2 + tagRelevance;

// Asset Quality (0-10)
assetQuality = resolutionScore * 0.4 + popularityScore * 0.6;

// Duration Fit (0-10)
durationFit = optimalDuration ? 10 : (actualDuration / targetDuration) * 10;
```

### Search Hierarchy Strategy

```
Scene Keywords: ["motivation", "success", "achievement"]
↓ No good results
Emotional Keywords: ["inspiration", "growth", "journey"]
↓ Still insufficient
Generic Keywords: ["business", "people", "nature"]
↓ Last resort
Universal Keywords: ["light", "abstract", "professional"]
```

### Database Schema Updates

```sql
-- Asset search results
CREATE TABLE asset_search_results (
  id TEXT PRIMARY KEY,
  script_id TEXT REFERENCES video_scripts(id),
  scene_number INTEGER,
  pexels_id INTEGER,
  asset_type TEXT CHECK (asset_type IN ('video', 'image')),
  url TEXT,
  thumbnail_url TEXT,
  photographer TEXT,
  relevance_score REAL,
  keywords_used TEXT,
  search_rank INTEGER,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Asset search jobs
CREATE TABLE asset_search_jobs (
  id TEXT PRIMARY KEY,
  script_id TEXT REFERENCES video_scripts(id),
  status TEXT CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  scenes_total INTEGER,
  scenes_completed INTEGER,
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  error_message TEXT
);
```

### Environment Variables

```
PEXELS_API_KEY=your_api_key_here
PEXELS_MAX_CONCURRENT=5
ASSET_CACHE_TTL_HOURS=24
ASSET_MIN_RESOLUTION=1080
VIDEO_MIN_DURATION=3
VIDEO_MAX_DURATION=30
```

### Testing Standards

- Mock Pexels API responses
- Test concurrent search processing
- Validate relevance scoring accuracy
- Test fallback search logic
- Performance testing with large scripts

## Change Log

| Date       | Version | Description            | Author    |
| ---------- | ------- | ---------------------- | --------- |
| 2025-08-26 | 1.0     | Initial story creation | John (PM) |

## Dev Agent Record

(To be populated during implementation)

## QA Results

(To be populated during QA review)
