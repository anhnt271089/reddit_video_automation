# Story 2.3: Pexels API Integration

## Status

Draft

## Story

**As a** video producer,  
**I want** automated visual asset discovery from Pexels using extracted keywords,  
**so that** I can find relevant background videos and images for each scene without manual searching.

## Acceptance Criteria

1. Pexels API key registration completed and configured
2. Asset search service implemented with keyword-based queries
3. Relevance scoring algorithm matches assets to scene content
4. Local file caching reduces API calls and improves performance
5. Fallback search hierarchies handle failed keyword matches
6. Rate limiting enforced at 200 requests per hour
7. Both video and image assets supported with metadata
8. Asset download and local storage management
9. Search result ranking prioritizes video quality and relevance

## Tasks / Subtasks

- [ ] **Task 1: Register for Pexels API** (AC: 1)
  - [ ] Visit https://www.pexels.com/api/ (USER ACTION)
  - [ ] Create Pexels account if needed (USER ACTION)
  - [ ] Generate API key from dashboard (USER ACTION)
  - [ ] Add PEXELS_API_KEY to .env files (USER ACTION)
  - [ ] Review API terms and rate limits
  - [ ] Document API key setup in README

- [ ] **Task 2: Create Pexels API Client** (AC: 2, 6)
  - [ ] Create src/services/pexels/client.ts
  - [ ] Implement API client with:
    - Authorization header handling
    - Request/response typing
    - Error handling for API failures
    - Rate limiting with request queuing
  - [ ] Add support for both endpoints:
    - /v1/search (images and videos)
    - /v1/videos/search (videos only)
  - [ ] Implement request logging
  - [ ] Test API connectivity

- [ ] **Task 3: Build Asset Search Service** (AC: 2, 9)
  - [ ] Create src/services/pexels/search.ts
  - [ ] Implement searchAssets function:
    - Accept keywords array and scene context
    - Format search queries for Pexels
    - Execute parallel searches for images/videos
    - Combine and rank results
  - [ ] Create search parameters optimization:
    - Orientation preference (landscape)
    - Size requirements (medium+)
    - Video duration filtering
  - [ ] Add search result deduplication
  - [ ] Test with various keyword combinations

- [ ] **Task 4: Implement Relevance Scoring** (AC: 3, 9)
  - [ ] Create src/services/pexels/scoring.ts
  - [ ] Implement relevance algorithm:
    - Keyword match scoring (40%)
    - Image quality metrics (30%)
    - Video duration suitability (20%)
    - Photographer reputation (10%)
  - [ ] Add semantic similarity checks:
    - Compare tags with scene keywords
    - Analyze asset descriptions
    - Consider emotional tone matching
  - [ ] Create ranking system
  - [ ] Test scoring accuracy with sample scenes

- [ ] **Task 5: Build Fallback Search System** (AC: 5)
  - [ ] Create keyword hierarchy system:
    - Primary: Specific extracted keywords
    - Secondary: Generic scene descriptors
    - Tertiary: Motivational stock keywords
  - [ ] Implement fallback logic:
    - Try primary keywords first
    - Fall back to broader terms
    - Use motivational defaults as last resort
  - [ ] Create fallback keyword database:
    - "motivation", "success", "journey"
    - "growth", "achievement", "inspiration"
    - "nature", "business", "people"
  - [ ] Test fallback effectiveness

- [ ] **Task 6: Implement Local Caching** (AC: 4, 8)
  - [ ] Create src/services/pexels/cache.ts
  - [ ] Implement file caching system:
    - Download assets to assets/cache/
    - Organize by asset type and ID
    - Track cache metadata in database
  - [ ] Add cache management:
    - TTL of 7 days for cached files
    - Cache size monitoring
    - Automatic cleanup of old files
  - [ ] Create cache warming strategy
  - [ ] Implement cache hit/miss logging

- [ ] **Task 7: Add Asset Download Management** (AC: 8)
  - [ ] Create asset download service:
    - Concurrent download handling
    - Progress tracking for large files
    - Retry logic for failed downloads
    - File integrity verification
  - [ ] Implement storage organization:
    - Folder structure by date/project
    - Filename conventions
    - Metadata file storage
  - [ ] Add download optimization:
    - Appropriate resolution selection
    - Compression for storage efficiency
  - [ ] Create download monitoring

- [ ] **Task 8: Create API Endpoints** (AC: 2, 8)
  - [ ] Create src/routes/api/assets.ts
  - [ ] Implement endpoints:
    - POST /api/assets/search - Search by keywords
    - GET /api/assets/:id - Get asset details
    - POST /api/assets/:id/download - Download asset
    - GET /api/assets/cache/stats - Cache statistics
  - [ ] Add request validation
  - [ ] Implement response formatting
  - [ ] Add error responses

## Dev Notes

### Architecture Context

- **API:** Pexels API v1
- **Rate Limits:** 200 requests/hour (free tier)
- **Supported Media:** Images and Videos
- **Cache Strategy:** Local file system storage

### Pexels API Endpoints

```
Base URL: https://api.pexels.com/v1

GET /search?query={keywords}&per_page=20&page=1
GET /videos/search?query={keywords}&per_page=20&page=1

Headers:
Authorization: YOUR_API_KEY
```

### Keyword Processing Strategy

```
Scene Keywords â†’ Search Strategy:
1. Direct keyword search
2. Synonym expansion
3. Category-based fallback
4. Generic motivational terms
```

### Asset Quality Criteria

- **Images:** Minimum 1920x1080, high quality
- **Videos:** Minimum 1080p, 3-30 seconds duration
- **Content:** Professional, relevant to keywords
- **Attribution:** Photographer credit preserved

### Environment Variables

```
PEXELS_API_KEY=your_api_key_here
PEXELS_REQUESTS_PER_HOUR=200
PEXELS_CACHE_TTL_DAYS=7
PEXELS_MAX_CONCURRENT_DOWNLOADS=3
```

### Testing Standards

- Mock Pexels API responses
- Test rate limiting behavior
- Verify cache functionality
- Test fallback search logic
- Validate asset quality scoring

## Change Log

| Date       | Version | Description            | Author    |
| ---------- | ------- | ---------------------- | --------- |
| 2025-08-26 | 1.0     | Initial story creation | John (PM) |

## Dev Agent Record

(To be populated during implementation)

## QA Results

(To be populated during QA review)
