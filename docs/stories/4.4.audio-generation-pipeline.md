# Story 4.4: Audio Generation Pipeline

## Status

Draft

## Story

**As a** content creator,  
**I want** an automated audio generation system that creates natural-sounding voiceovers from scripts using ElevenLabs TTS,  
**so that** I can produce professional-quality narration that brings my video content to life with consistent voice and pacing.

## Acceptance Criteria

1. TTS integration generates natural speech from script text using ElevenLabs API
2. Voice selection system chooses appropriate voice models for different content types
3. Script preprocessing optimizes text for speech synthesis (pauses, emphasis, pronunciation)
4. Audio processing applies post-generation enhancements (timing, quality, normalization)
5. Scene-based generation creates separate audio files per scene for editing flexibility
6. Quality control validates generated audio meets professional standards
7. Audio caching reduces regeneration costs and improves response times
8. Batch processing handles multiple scene generation efficiently
9. Audio export provides final voiceover tracks for video composition pipeline

## Tasks / Subtasks

- [ ] **Task 1: Build ElevenLabs TTS Integration** (AC: 1, 8)
  - [ ] Create src/services/audio/elevenLabsClient.ts
  - [ ] Implement TTS API integration:
    - ElevenLabs API authentication and configuration
    - Text-to-speech request handling
    - Audio stream processing and storage
    - Error handling and retry logic
  - [ ] Add API management:
    - Rate limiting and quota monitoring
    - Request batching for efficiency
    - API key rotation support
    - Usage tracking and analytics
  - [ ] Create audio format handling:
    - Support multiple output formats (MP3, WAV)
    - Quality settings configuration
    - Sample rate optimization
    - File size optimization
  - [ ] Test API integration with various text inputs

- [ ] **Task 2: Implement Voice Selection System** (AC: 2)
  - [ ] Create src/services/audio/voiceManager.ts
  - [ ] Build voice model management:
    - Available voice catalog maintenance
    - Voice characteristic profiling
    - Content-type to voice matching
    - Voice preview generation
  - [ ] Implement selection algorithm:
    - Content tone analysis for voice matching
    - Gender and age appropriateness
    - Accent and language considerations
    - Brand voice consistency
  - [ ] Add voice categories:
    - Professional/Business (clear, authoritative)
    - Motivational/Inspirational (energetic, uplifting)
    - Educational/Informative (clear, measured)
    - Conversational/Casual (friendly, approachable)
  - [ ] Create voice testing system:
    - Sample generation for voice evaluation
    - A/B testing between voice options
    - Voice quality assessment
    - User preference tracking

- [ ] **Task 3: Build Script Preprocessing Pipeline** (AC: 3)
  - [ ] Create src/services/audio/scriptPreprocessor.ts
  - [ ] Implement text optimization:
    - SSML markup generation for better speech
    - Pause insertion at natural break points
    - Emphasis marking for important words
    - Pronunciation guide integration
  - [ ] Add speech enhancement:
    - Sentence structure optimization
    - Reading pace adjustment markers
    - Breathing pause insertion
    - Emotional tone markers
  - [ ] Create text cleaning:
    - Remove formatting artifacts
    - Handle special characters and symbols
    - Expand abbreviations and acronyms
    - Normalize number and date pronunciation
  - [ ] Build preprocessing validation:
    - Text length limits per scene
    - SSML syntax validation
    - Pronunciation accuracy checking
    - Speech timing estimation

- [ ] **Task 4: Implement Scene-Based Generation** (AC: 5, 8)
  - [ ] Create scene generation orchestrator:
    - Process scenes in parallel where possible
    - Maintain consistent voice across scenes
    - Handle scene-specific voice modifications
    - Track generation progress per scene
  - [ ] Build scene audio management:
    - Individual scene audio file creation
    - Scene timing metadata storage
    - Cross-scene voice consistency checking
    - Scene-specific quality validation
  - [ ] Add generation optimization:
    - Batch multiple scenes in single API calls
    - Optimize API usage for cost efficiency
    - Cache common text segments
    - Reuse audio for identical text
  - [ ] Create scene coordination:
    - Ensure voice consistency across scenes
    - Handle scene transitions smoothly
    - Manage scene-specific emphasis
    - Coordinate with background music timing

- [ ] **Task 5: Build Audio Processing Pipeline** (AC: 4, 6)
  - [ ] Create src/services/audio/audioProcessor.ts
  - [ ] Implement post-generation enhancement:
    - Audio normalization and leveling
    - Noise reduction and cleanup
    - Dynamic range optimization
    - Speech clarity enhancement
  - [ ] Add timing adjustments:
    - Pause length standardization
    - Speech rate consistency
    - Scene boundary silence handling
    - Overall pacing optimization
  - [ ] Create quality improvements:
    - Breath sound removal/reduction
    - Mouth sound cleanup
    - Volume consistency across scenes
    - Frequency response optimization
  - [ ] Build audio validation:
    - Quality metrics calculation
    - Clipping detection and correction
    - Speech intelligibility scoring
    - Technical standard compliance

- [ ] **Task 6: Implement Quality Control System** (AC: 6)
  - [ ] Create audio quality analyzer:
    - Speech clarity measurement
    - Audio level consistency checking
    - Pronunciation accuracy validation
    - Emotional tone appropriateness
  - [ ] Build quality metrics:
    - Signal-to-noise ratio measurement
    - Dynamic range assessment
    - Frequency response analysis
    - Speech intelligibility scoring
  - [ ] Add quality thresholds:
    - Minimum quality standards
    - Automatic regeneration triggers
    - Manual review flagging
    - Quality improvement suggestions
  - [ ] Create quality reporting:
    - Per-scene quality reports
    - Overall project quality assessment
    - Quality trend tracking
    - Improvement recommendations

- [ ] **Task 7: Build Audio Caching System** (AC: 7)
  - [ ] Create src/services/audio/audioCache.ts
  - [ ] Implement intelligent caching:
    - Text hash-based cache keys
    - Voice model version tracking
    - Scene-level cache granularity
    - Cache invalidation strategies
  - [ ] Add cache management:
    - Storage space optimization
    - Cache hit rate monitoring
    - Automatic cache cleanup
    - Cache warm-up strategies
  - [ ] Create cache persistence:
    - Database metadata storage
    - File system audio storage
    - Cache rebuild on startup
    - Cache synchronization across instances
  - [ ] Build cache analytics:
    - Cache usage statistics
    - Cost savings calculation
    - Performance impact measurement
    - Cache optimization recommendations

- [ ] **Task 8: Create Generation Queue Management** (AC: 8, 9)
  - [ ] Build generation queue system:
    - Priority-based job processing
    - Concurrent generation limits
    - Queue status monitoring
    - Failed job retry handling
  - [ ] Implement job processing:
    - Scene-level job granularity
    - Progress tracking per job
    - Resource usage monitoring
    - Completion notifications
  - [ ] Add queue optimization:
    - Batch similar requests
    - Load balancing across API limits
    - Priority handling for urgent requests
    - Queue performance analytics
  - [ ] Create monitoring dashboard:
    - Real-time queue status
    - Processing time metrics
    - Error rate tracking
    - Resource utilization graphs

- [ ] **Task 9: Build Audio Export System** (AC: 9)
  - [ ] Create export functionality:
    - Generate final scene audio files
    - Create audio manifest for video pipeline
    - Package audio with timing metadata
    - Validate export completeness
  - [ ] Implement export formats:
    - High-quality WAV for video editing
    - Compressed MP3 for web delivery
    - Metadata-rich audio files
    - Multiple quality tier exports
  - [ ] Add export validation:
    - File integrity checking
    - Audio quality verification
    - Timing accuracy validation
    - Format compatibility testing
  - [ ] Create pipeline integration:
    - Trigger video composition pipeline
    - Provide audio-to-video synchronization data
    - Handle export failure recovery
    - Track export success metrics

- [ ] **Task 10: Create Audio Generation API** (AC: 1, 5, 9)
  - [ ] Create src/routes/api/audio.ts
  - [ ] Implement generation endpoints:
    - POST /api/audio/generate/:scriptId - Trigger full audio generation
    - POST /api/audio/scene/:sceneId - Generate single scene audio
    - GET /api/audio/status/:jobId - Check generation progress
    - GET /api/audio/preview/:sceneId - Get scene audio preview
  - [ ] Add management endpoints:
    - GET /api/audio/voices - List available voices
    - POST /api/audio/voice/test - Test voice with sample text
    - GET /api/audio/cache/stats - Cache performance statistics
    - DELETE /api/audio/regenerate/:sceneId - Force scene regeneration
  - [ ] Create WebSocket integration:
    - Real-time generation progress updates
    - Queue position notifications
    - Completion announcements
    - Error notifications
  - [ ] Test API performance and reliability

## Dev Notes

### Architecture Context

- **TTS Service:** ElevenLabs API with professional voice models
- **Audio Processing:** Node.js with `fluent-ffmpeg` and audio libraries
- **Caching:** File system + database for efficient reuse
- **Queue System:** Bull queue with Redis for job management

### Audio Generation Flow

```
Script Approved → Text Preprocessing → Voice Selection →
Scene Segmentation → TTS Generation → Audio Processing →
Quality Control → Caching → Export → Video Pipeline
```

### Voice Selection Algorithm

```typescript
interface VoiceProfile {
  id: string;
  name: string;
  gender: 'male' | 'female' | 'neutral';
  age: 'young' | 'adult' | 'mature';
  accent: string;
  style: 'professional' | 'conversational' | 'dramatic';
  energy: number; // 0-10
  clarity: number; // 0-10
  suitability_scores: {
    motivational: number;
    educational: number;
    commercial: number;
    narrative: number;
  };
}

function selectOptimalVoice(script: VideoScript): VoiceProfile {
  const contentAnalysis = analyzeContentTone(script);
  const voiceScores = availableVoices.map(voice => ({
    voice,
    score: calculateVoiceCompatibility(voice, contentAnalysis),
  }));

  return voiceScores.sort((a, b) => b.score - a.score)[0].voice;
}
```

### SSML Enhancement

```typescript
function generateSSML(text: string, sceneContext: SceneBreakdown): string {
  let ssml = `<speak>`;

  // Add speaking rate based on scene emotional tone
  const rate = calculateSpeakingRate(sceneContext.emotional_tone);
  ssml += `<prosody rate="${rate}">`;

  // Process text for natural speech
  const processedText = text
    .replace(/\. /g, '. <break time="0.5s"/>') // Natural pauses
    .replace(/! /g, '! <break time="0.7s"/>') // Longer pause after exclamations
    .replace(/\? /g, '? <break time="0.6s"/>') // Question pauses
    .replace(/([A-Z]{2,})/g, '<say-as interpret-as="spell-out">$1</say-as>'); // Spell acronyms

  ssml += processedText;
  ssml += `</prosody></speak>`;

  return ssml;
}
```

### Audio Quality Metrics

```typescript
interface AudioQualityMetrics {
  snr: number; // Signal-to-noise ratio
  lufs: number; // Loudness Units relative to Full Scale
  dynamicRange: number; // Dynamic range in dB
  speechClarity: number; // Speech intelligibility score (0-100)
  consistency: number; // Volume consistency across scenes
  artifacts: number; // Count of audio artifacts detected
}

const QUALITY_THRESHOLDS = {
  snr: 40, // Minimum 40dB SNR
  lufs: -16, // Target -16 LUFS for video content
  dynamicRange: 15, // Minimum 15dB dynamic range
  speechClarity: 85, // Minimum 85% intelligibility
  consistency: 0.9, // 90% volume consistency
  artifacts: 0, // Zero tolerance for major artifacts
};
```

### Database Schema Updates

```sql
-- Audio generation jobs and tracking
CREATE TABLE audio_generation_jobs (
  id TEXT PRIMARY KEY,
  script_id TEXT REFERENCES video_scripts(id),
  status TEXT CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  voice_id TEXT,
  scenes_total INTEGER,
  scenes_completed INTEGER,
  started_at TIMESTAMP,
  completed_at TIMESTAMP,
  error_message TEXT,
  cost_estimate REAL,
  actual_cost REAL
);

-- Generated audio files per scene
CREATE TABLE generated_audio (
  id TEXT PRIMARY KEY,
  script_id TEXT REFERENCES video_scripts(id),
  scene_number INTEGER,
  audio_file_path TEXT,
  duration REAL,
  voice_id TEXT,
  quality_score REAL,
  generation_settings JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Audio cache for reuse
CREATE TABLE audio_cache (
  id TEXT PRIMARY KEY,
  text_hash TEXT UNIQUE,
  voice_id TEXT,
  audio_file_path TEXT,
  duration REAL,
  usage_count INTEGER DEFAULT 0,
  last_used TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### Cost Optimization Strategy

```typescript
interface CostOptimization {
  // Cache strategy to minimize API calls
  textHashCaching: boolean;

  // Batch processing for efficiency
  sceneBatching: boolean;
  maxBatchSize: number;

  // Quality vs cost balance
  qualityTier: 'standard' | 'premium' | 'ultra';

  // Usage monitoring
  monthlyCostLimit: number;
  alertThreshold: number;
}

// Estimate generation costs
function estimateGenerationCost(script: VideoScript): number {
  const totalCharacters = script.scene_breakdown.reduce(
    (total, scene) => total + scene.content.length,
    0
  );

  const costPerCharacter = 0.0001; // $0.0001 per character (example rate)
  return totalCharacters * costPerCharacter;
}
```

### Performance Considerations

- Implement audio streaming for large files
- Use compression for cached audio files
- Optimize SSML for faster TTS processing
- Monitor API rate limits and queue accordingly
- Cache processed audio segments aggressively

### Testing Standards

- TTS API integration tests with mock responses
- Audio quality validation tests
- Cache performance and accuracy tests
- Queue processing under load tests
- End-to-end audio generation workflow tests

## Change Log

| Date       | Version | Description            | Author    |
| ---------- | ------- | ---------------------- | --------- |
| 2025-08-26 | 1.0     | Initial story creation | John (PM) |

## Dev Agent Record

(To be populated during implementation)

## QA Results

(To be populated during QA review)
